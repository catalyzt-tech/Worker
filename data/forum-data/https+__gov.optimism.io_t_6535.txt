{
  "title": "NanoQF a minimal grants protocol on EAS",
  "content": "NANOQF\n\nThis document explores what a minimal protocol for grants could look like with\nthe goals of being simple and easy to extend. It’s built on Safe and EAS.\n\nThe goals with NanoQF are:\n\n * attest projects and voters to be eligible to be included in round\n * ability to fund projects\n * ability to pool funds into a Safe\n * distribute funds to projects based on events to and from attested voters and\n   projects\n * easy to query data\n\nIt’s guided by these questions:\n\n * What if each project is represented by any address\n   * EOA, AA, Escrow, PaymentSplitter (the platform can decide how projects are\n     created)\n * What if token transfers to addresses is the basis for voting rather than\n   contract calls\n   * CountingService filters approved voters and projects\n * What if Ethereum Attestation Service is used to approve projects and voters\n\n\nCOMPONENTS\n\n * Round contract: pools matching funds and sets Merkle tree for distribution\n   claims. This is a Safe Multisig.\n * Attestation service: approves projects valid for distribution of funds\n * Attestation service: approves voters to include in counting\n * Counting service: counts votes for each project, calculates distribution, and\n   updates MerkleTree\n\nThe attestation and counting services are meant to be modular. Anyone can build\nthese and share. See code examples further down.\n\n\nOVERVIEW OF FLOW\n\n 1. Organizers deploy a Round contract to pool matching funds.\n 2. Supporters transfer funds to the Round contract.\n 3. Creators have their projects attested. (can be re-used in other rounds)\n 4. Voters have their addresses attested. (can be re-used in other rounds)\n 5. Voting on projects takes place. (any token transfer to project address)\n 6. Votes are calculated and a Merkle Tree of distribution claims is created.\n 7. Projects claim their matching funds.\n\n\nKEY FEATURES\n\n * Only one contract to deploy, making it more efficient than existing\n   platforms.\n * Ethereum Attestation Service (EAS) is used to approve projects and voters. By\n   using EAS, a variety of attestation methods can be utilized, such as Gitcoin\n   Passport, Zuzalu, Stripe KYC, and others. This also acts as a project\n   registry.\n * Voting can be done without calling any contracts by simply transferring\n   tokens within the rounds’ start and end blocks.\n\n\nCODE IMPLEMENTATION\n\nHere are code snippets for Vote Counting Service, Attestation Service, and the\nRound contract:\n\nVote Counting Service\n\nThe vote counting service does the following:\n\n * Get the attested projects and voters from specified attester services\n * Get all the voting token transfers within start and end block\n * Get the funding token balance of the Round contract\n * Calculate the quadratic distribution (or any other strategy)\n * Generate a Merkle Tree with distribution so project owners can claim their\n   matching funds\n\nThis can theoretically run on either backend or frontend. Repl.it is also viable\nand simple.\n\nconst round = new Contract(roundAddress, roundABI);\nconst config = await round.config();\n\nconst fundingToken = new Contract(config.fundingToken, erc20ABI);\nconst votingToken = new Contract(config.votingToken, erc20ABI);\n\n// Query EAS for attestations\nconst approvedVoters = await eas.query({\n  schemaId: approvedVotersSchema,\n  // voter with any of these attestations considered valid\n  attester: { in: [passportAttester, stripeAttester, zupassAttester] },\n});\nconst approvedProjects = await eas.query({\n  schemaId: approvedProjectsSchema,\n  attester: { in: [zupassAttester] },\n});\n\n// How much funding in the contract - used for qf calculation\nconst matchingFunds = await fundingToken.balanceOf(roundAddress);\n\n\nvotingToken.queryFilter(\n    // Get all token transfers within the round time span\n    votingToken.filters.Transfer(),\n    config.startBlock,\n    config.endBlock\n  )\n  .then((votes) =>\n    votes.filter(\n      (vote) =>\n        // Vote must be cast to an approved project from an approved user\n        approvedProjects.includes(vote.args.to) &&\n        approvedVoters.includes(vote.args.from)\n    )\n  )\n  .then(async (validVotes) =>\n    // Calculate QF and create Merkle from the filtered votes\n    createMerkleTree(calculateQuadratic(validVotes, matchingFunds))\n  )\n  .then((merkle) => \n    // Update Round contract with distribution Merkle\n    round.setMerkle(merkle)\n   );\n\nfunction calculateQuadratic(votes, funds) {\n  // Calculate distribution...\n}\nfunction createMerkleTree(values) {\n  // https://github.com/OpenZeppelin/merkle-tree\n  return StandardMerkleTree.of(values, [\"address\", \"uint256\"]);\n}\n\n\nAttestation Service\n\nAttestation Services can be created and run by anyone. Here’s an example of an\napi endpoint that verifies a Zuzalu membership before creating an attestation.\n\nfunction zupassAttestation(req, res) {\n  await verifyZupassProof(req.body.proof);\n\n  const attestation = await createAttestation(req.body);\n  res.status(201).send({ attestation });\n}\n\n\nRound Contract\n\nThe round contract does the following:\n\n * Contain a pointer to metadata (use Ceramic so data can be updated?)\n * Configuration for funding and voting tokens\n * Timespan for when to count votes\n * Function to set merkle root by the owners\n * Function to claim matching funds by the project owners\n\ncontract Round is SafeMultisig {\n  struct Config {\n    string metadata; // title, description, ...\n    address fundingToken;\n    address votingToken;\n    uint256 startBlock;\n    uint256 endBlock;\n  };\n  bytes32 public root;\n  Config public config;\n\n  function initialize(Config _config) initializer {...}\n  function setMerkle(_root) authorized public {...}\n  function claim(bytes32 calldata proof, uint256 amount) {...}\n}\n\n\n\nQUESTIONS\n\n\nWHY THIS SOLUTION?\n\nOnly one contract with clear responsibilities: a multisig contract that holds\nand distribute funds. Safe multisig handles logic for authorizing.\n\nSimple services that attest legitimacy of projects and voters as well as\nstrategies for counting votes. These can easily be shared in a registry. Easy to\nquery projects from EAS based on schemaId, attestationId or other params.\n\nTake any list of addresses and create attestations to approve them for round.\nFor example CSV, Excel, Airtable, …\n\nBy using Transfer events to count votes we can easily choose the action to count\nas vote. It’s trivial to query ERC721 or ERC1155 Transfer events and build new\ncounting services. We could even query the chain for governance Vote or any\nother event.\n\n\nIF VOTES ARE ERC20 TRANSFERS, HOW DO WE KNOW WHAT ROUND THE VOTE BELONGS TO?\n\nWe don’t. The VoteCounting service will count all transfers to the project\naddress coming from a valid voter as a vote.\n\nIf this is important, there are a few potential solutions:\n\n * Changing the approved voters list - The Round has an AttestationService just\n   for this round. Each voter would need to get their address attested.\n * Changing the approved projects list - The Project has a unique address just\n   for this Round.\n\n\nHOW CAN THE VOTERS TRUST THE VOTE COUNTER SERVICES?\n\nAnyone can query the chain for donations and calculate the quadratic\ndistribution and come up with the correct distribution of matching funds.",
  "views": 622,
  "like_count": 1,
  "word_count": 1002,
  "answer": [],
  "created_at": "2023-07-29T13:14:16.162Z"
}