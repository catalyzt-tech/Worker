{
  "title": "Shutterized Optimism – An Encrypted Mempool for the OP Stack",
  "content": "SHUTTERIZED OPTIMISM – AN ENCRYPTED MEMPOOL FOR THE OP STACK\n\n\nREQUIREMENTS AND TECHNICAL ARCHITECTURE\n\nAuthors: Jannik Luhn, Maximilian Langenfeld, Luis Bezzenberger, Jakub Al Soori\n\n\nEXECUTIVE SUMMARY\n\nThis document serves as a requirements and technical architecture document for a\nthreshold encryption-based front-running protection mechanism for the OP Stack\nand Bedrock codebase, capitalizing on the capabilities of the Shutter Network.\nThe mechanism targets the reduction of front-running and MEV-related exploits in\nthe Ethereum DeFi ecosystem by adopting a shielded mempool using threshold\nencryption.\n\nBy integrating this mechanism, we foresee OP Stack-based rollups becoming more\nsecure and efficient layers, attracting safer trading for DeFi users, more\nrobust censorship resistance, and increased profitability. Moreover, the\nsequencer operators will be able to claim immunity from front-running and\ncensoring transactions by design, while retaining their ability to collect\nand/or distribute back-running related MEV.\n\nDecentralized Sequencer and MEVA designs are largely orthogonal to this proposal\nand complement it well.\n\n\nTABLE OF CONTENTS\n\n 1. Executive Summary\n 2. Table of Contents\n 3. Introduction and Goals\n    3.1. Problem Statement\n    3.1.1. Malicious MEV and Censorship\n    3.1.2. MEV and Censorship on Layer 2 (L2)\n    3.1.3. Regulatory Implications\n    3.2. MEV mitigation solutions overview\n    3.3. OP Stack\n    3.4 Shutter Network\n 4. Participant Requirements\n    4.1 End User\n    4.2 Dapp Project\n    4.3 Optimism Rollup Node\n    4.4 Optimism Sequencer\n    5 Component Requirements\n    5.1 Functional Requirements\n    5.1.1 Optimism Rollup Node\n    5.1.2 Optimism Sequencer Node\n    5.1.3 Keyper\n    5.1.4 Front End Library\n    5.2 Non-functional Requirements\n 5. Technical Architecture of Shutterized Optimism\n    6.1 Overview\n    6.2 Components\n    6.2.1 Keyper Set\n    6.2.2 Sequencer\n    6.2.3 System Contracts\n    6.2.4 Client Library\n    6.3 Code Modifications\n    6.3.1 Shutter Inbox Contract\n    6.3.2 Keyper Set Contract\n    6.3.3 Key Broadcast Contract\n    6.3.4 Engine API\n    6.3.5 op-node\n    6.3.6 op-geth\n    6.4 User Interaction\n    6.5 Interaction With Decentralized Sequencers\n    6.6 Finality Assumption\n    6.7 Potential Issues and Solutions\n    6.7.1 Liveness Failures\n    6.7.2 Latency\n    6.7.3 Sequencer Side-Channel Attack\n 6. Design Options\n    7.1 Block or Transaction Keys\n 7. Future Considerations\n 8. Conclusion\n\n\nINTRODUCTION AND GOALS\n\nThis document presents requirements and an architecture proposal for a threshold\nencryption-based front-running protection mechanism for the OP Stack and Bedrock\ncodebase, leveraging the Shutter Network. The mechanism aims to provide\nfront-running protection using an encrypted/shielded mempool and threshold\nencryption, as proposed in Shutter Network’s Optimism Governance Forum post\n[https://gov.optimism.io/t/draft-gf-phase-1-proposal-front-running-protection-via-shielded-mempool-for-op-stack-using-threshold-encryption/5036].\n\nWe think by adopting this mechanism, OP Stack-based rollups become better, more\nneutral base layers and can gain the following benefits:\n\n * Safer trading for DEFI users (no front-running)\n * Added censorship resistance (even for centralized sequencers)\n * More profitable trading for DEFI users (because less value lost due to\n   malicious MEV)\n * Sequencer can plausibly argue that they no longer have the ability to\n   front-run transactions nor censor transactions based on their content by\n   design (potential compliance, image and regulatory benefits for the sequencer\n   operator)\n * Sequencer still retains the ability to collect or distribute back-running\n   related MEV (arbitrage and liquidations)\n\nThis document begins with a goals/motivation section, then presents a two-phase\nprocess for defining the architecture of a threshold encryption-based\nfront-running protection mechanism for the OP Stack and Bedrock codebase,\nleveraging the Shutter Network.\n\nThe process starts with Phase 1, where high-level, solution-agnostic\nrequirements for the mechanism are defined. This phase is primarily driven by\nthe perspectives and needs of the end users and the sequencer, with requirements\ncategorized by actors in the system.\n\nFollowing this, Phase 2 transitions to defining Shutter-specific requirements,\nfocusing more on the details of the proposed implementation. These requirements\nare categorized by expected technical components in the system.\n\nIt then outlines the user interaction with the system, followed by the core of\nthe document, the technical architecture section. Within this section, the\ntechnical components and code modifications are outlined, a transaction flow\ndiagram is given, among other things.\n\nThe document closes with a conclusion and future considerations.\n\n\nPROBLEM STATEMENT\n\nThe rising popularity of Ethereum’s open finance (DeFi) ecosystem has led to an\nincreasing amount of maximal extractable value (MEV). Unfortunately, it has also\nexposed the network to potential exploitation through front-running and other\nMEV-related tactics, which can deter prospective investors and traders.\nFurthermore, the measures put in place to manage this issue have proven to be\nsuboptimal, introducing unnecessary trust assumptions and centralization\nfactors. For instance, MEV relays, though beneficial for market health, require\na high degree of trust, making them unsustainable in their current form. To\nunlock the billions in side-lined investment and ensure Ethereum’s long-term\nbase layer neutrality, an effective approach to transaction ordering and\ninclusion is required.\n\n\nMALICIOUS MEV AND CENSORSHIP\n\nFront-running and malicious MEV extraction pose significant threats to\nEthereum’s ecosystem. Front-running involves the unethical practice of a broker\nexecuting orders on a security for its own account while taking advantage of\nadvance knowledge of pending orders from its customers. On Ethereum, this has\nresulted in a measurable amount of value extraction from users. MEV relays,\nwhich were introduced as a solution, unfortunately introduce centralization\nrisks due to the required high degree of trust.\n\nThis tendency to centralize parts of the transaction supply chain infrastructure\nnot only adds censorship vectors but also facilitates actual censorship\n[https://valitraitors.info/] on the protocol level, as evidenced by instances of\nadherence to sanctions lists such as the Office of Foreign Assets Control (OFAC)\nlist.\n\n\nMEV AND CENSORSHIP ON LAYER 2 (L2)\n\nLayer 2 solutions, which aim to scale Ethereum’s network by processing\ntransactions off the main blockchain, face a similar yet distinct set of\nchallenges. Here, the problem lies in the private mempools and potential\nspamming issues. Currently, rollup sequencers — responsible for collecting and\nsubmitting transactions on L2 — are trusted not to extract MEV. However, this\ncentralized approach could potentially amplify the MEV issue in the long term.\nTo avoid front-running, we place our trust in the sequencer, inadvertently\nconsolidating their power, thus creating an unsustainable and censorship\nsusceptible system.\n\n\nREGULATORY IMPLICATIONS\n\nThe regulatory landscape poses another challenge. Regulatory bodies worldwide\nhave begun to clamp down on front-running, potentially categorizing sequencers\nwho extract malicious MEV as financial intermediaries, rather than purely\ntechnical entities. This could complicate compliance, as financial\nintermediaries are subjected to stringent regulatory requirements. Consequently,\nwithout proper management of MEV, Ethereum could face stricter regulations,\ndeterring users and stifling growth in the DeFi sector.\n\n\nMEV MITIGATION SOLUTIONS OVERVIEW\n\n 1. Proposer Builder Separation (PBS): Proposer-builder separation (PBS) is a\n    proposed upgrade for Ethereum that divides the tasks of creating and\n    broadcasting blocks between multiple validators, enhancing censorship\n    resistance, preventing hobbyist validators from being outcompeted by\n    institutional players, and aiding Ethereum’s scalability; it also\n    reconfigures the economics of maximum extractable value (MEV), allowing any\n    validator to benefit from sophisticated MEV extraction performed by block\n    builders.\n 2. MEV Auctions (Optimism MEVA): Optimism MEVA is a proposal for an\n    auction-based system where proposers bid for the right to order transactions\n    within a block, reducing the potential for MEV extraction.\n 3. MEV Revenue Sharing Approaches: These approaches involve mechanisms that\n    redistribute MEV to various stakeholders, thus diminishing the potential\n    profits from malicious extraction.\n 4. Trust in Sequencer or MEV Relay to Not Front-run: This approach depends on\n    the trustworthiness of a sequencer or MEV relay to act in the best interests\n    of users and not engage in front-running.\n 5. Encrypted Mempools: Encrypted mempools are a way to hide transaction\n    information until it is included in a block, preventing front-running and\n    other MEV extraction tactics.\n\nSolution Comparison Table\n\nSolution Reduces or Redistributes MEV? Trust Requirement Proposer Builder\nSeparation (PBS) Redistributes Separates trust requirements MEV Auctions (e.g.\nOptimism MEVA) Redistributes Depends on specific implementation MEV Revenue\nSharing Approaches Redistributes Usually introduces additional trust\nrequirements Trust in Sequencer or MEV Relay to Not Front-run Reduces Introduces\nadditional trust requirements Encrypted Mempools Reduces Reduces trust\nrequirements\n\nIn conclusion, a comprehensive solution to the MEV problem may involve a\ncombination of multiple strategies. For instance, encrypted mempools could be\nused to significantly reduce malicious MEV, and then redistribution frameworks\nsuch as Optimism MEVA could be applied to manage the remaining MEV. The goal is\nto balance the need for trust with the potential to reduce or redistribute MEV\neffectively.\n\n\nOP STACK\n\nThe OP Stack, managed by the Optimism Collective, is a standardized, shared, and\nopen-source development stack that fuels Optimism. Currently powering the\nOptimism Mainnet, it’s expected to evolve and shape the Optimism Superchain and\nits governance. Its design promotes a shared, high-quality system for creating\nnew L2 blockchains, minimizing the need for siloed software development.\n\nThe “Optimism Bedrock” is the latest iteration of the OP Stack, providing tools\nto launch production-quality Optimistic Rollup blockchains. It’s designed to\nsupport the Optimism Superchain, a proposed network of L2s that share security,\ncommunication layers, and a common development stack.\n\nAs an evolving concept, the OP Stack will grow and adapt with Optimism, aiming\nto simplify the deployment of new L2 Rollups and foster interoperability among\ndifferent chains within the Superchain ecosystem. For those interested,\nresources are available to explore the OP Stack further and launch a\nSuperchain-ready L2.\n\n\nSHUTTER NETWORK\n\nShutter is an anti-frontrunning, malicious MEV-preventing protocol using\nthreshold encryption. It’s intended to be used as a plugin by any L1/L2 protocol\nto provide front-running and censorship resistance via implementing a\nshielded/encrypted mempool.\n\nShutter incorporates a Distributed Key Generation (DKG) scheme into an L1 or L2\nrollup sequencer mechanism to protect all dapps deployed on the rollup by\ndefault while also improving censorship resistance and potentially latency\nproperties. In principle, it operates by making the sequencer accept encrypted\ntransactions in their blocks and revealing and executing them only once they are\nordered.",
  "views": 4067,
  "like_count": 22,
  "word_count": 6192,
  "answer": [
    {
      "content": "CODE MODIFICATIONS\n\nThis section describes the main modifications that have to be implemented on top\nof the existing OP Stack and Bedrock codebase. In addition, it describes the\nrequired system contracts.\n\n\nSHUTTER INBOX CONTRACT\n\nThe central system contract is the Shutter Inbox Contract. It exposes the commit\nfunction which can be called by standard Ethereum transactions. In the\nfollowing, those are named Commit Transactions.\n\nThe user encrypts a payload, consisting of data, value and to fields, and\nattaches this in serialized form as an argument to the commit call. Additional\narguments are the future block-number when the transaction has to be executed as\nwell as the estimated gas-limit for the execution. The Commit Transaction has to\ninclude an ETH-transfer to the contract via the transaction’s value field, so\nthat the amount is equal to the gas-limit argument multiplied by the gas-price\nof the Commit Transaction.\n\nThe contract will store a FIFO-queue of the passed in arguments together with\nthe sender address in its storage. The contract makes sure that the cumulative\ngas-limits of the queue can never surpass the block-gas-limit, otherwise the\ncontract call fails. In order to keep the total state-growth constant, the\ncontract will only accept and enqueue transactions where the block-number\nargument equals the next block number, and the contract will delete all previous\ntransactions from the queue once they are handled in the Reveal Transaction. The\naccumulated gas transferred to the contract via the Commit Transactions can be\nwithdrawn by a configurable account, e.g. the sequencer or a DAO.\n\n\nKEYPER SET CONTRACT\n\nThe Keyper Set Contract manages the current keyper set. It allows an owner, e.g.\nthe OP DAO, to add and remove members at will at certain block numbers. The\nkeyper set contract also defines an emergency shutdown mechanism described in\nmore detail in the “Potential Issues and Solutions” section.\n\n\nKEY BROADCAST CONTRACT\n\nThe Key Broadcast Contract is a simple billboard that allows any keyper set to\nbroadcast its eon public key after they generated it. Users can fetch it from\nthere.\n\n\nENGINE API\n\nIn order to include the decryption key in the block and make it available in the\nstate-transition-function (STF), it has to be passed from the receiving end\n(op-node) to the block-building engine in op-geth. Therefore the EngineAPI\npayload-attributes for the engine_forkChoiceUpdatedV1 have to be extended to\ninclude a decryption-key field.\n\n\nOP-NODE\n\nThe op-node is responsible for initiating the construction and release of new\nblocks in the op-geth node in regular intervals. It does so by continuously\nadding transactions to the block candidate at all times. This process now has to\nbe paused briefly after each proposed block until the keypers have produced the\ndecryption key.\n\nConcretely, the time between a sequencer’s unsafe head update and the successful\nkeyper-decryption process blocks the execution of the next call to\nengine_forkChoiceUpdatedV1. Since the decryption key generation time is\nvariable, the op-node adjusts the time for successive calls to\nengine_getPayloadV1 / engine_newPayloadV1 in order to keep the overall block\ntime constant.\n\nThe op-node additionally communicates with the set of keypers by operating a\nlibp2p module that connects to the keypers and subscribes to a decryption-key\ntopic via the gossipsub protocol. The op-node has to have access to the current\nlayer 2 blockchain state, in order to verify keyper-set membership and the\nvalidity of received decryption keys.\n\n\nOP-GETH\n\nThe miner in op-geth is responsible for assembling new blocks. To do so, it\npicks transactions from the sorted mempool as well as deposit-transactions\nreceived from the op-node via the payload-attributes of the EngineAPI.\n\nBlock-building is initiated by the op-node via the Engine API. In this process,\nadditional constraints have to be fulfilled and considered for block validity.\nIt requires the decryption key for transactions included in the previous block,\nwhich the miner receives via the payload-attributes from the op-node.\n\nThe first transaction to be executed in the block’s state-transition function is\nthe special Reveal Transaction. It is exclusively assembled by the miner and\ncontains the decryption key. It fetches the encrypted payloads for this block\nfrom the Shutter Inbox Contract and decrypts them. Subsequently, it executes it,\ntaking the corresponding metadata fields sender and gas limit into account. Note\nthat the gas for the transaction has already been paid for by Commit\nTransaction.\n\nAfter successful execution of the decrypted payload, the resulting events of all\ndecrypted transactions are included in the receipt of the Reveal Transaction. In\nthe remainder of the block, the miner includes new transactions from the mempool\nas usual, including Commit Transactions for the next block. The miner takes the\nexecution gas limit of the latter into account in the scoring function used for\nmempool ordering.\n\n\n\nblock-building\n[https://europe1.discourse-cdn.com/bc41dd/optimized/2X/8/899518b9b71fb5b44b95b7b621d789f0f5664252_2_439x500.png]\nblock-building1004×1142 74.3 KB\n[https://europe1.discourse-cdn.com/bc41dd/original/2X/8/899518b9b71fb5b44b95b7b621d789f0f5664252.png]\n\n\n\nSequence diagram of the block building process. Two iterations of block building\nare shown - in the first, only the inclusion of normal transactions is shown in\ndetail. In the second, only the inclusion of the Reveal Transaction is shown in\ndetail. “NextBlock” represents the current locally built block within the\nsequencer’s memory. “Layer2State” represents the publicly visible unsafe head\nstate of the layer 2 blockchain. (high res\n[https://drive.google.com/file/d/1Fn914LBeP9gX6uUcPA6U7K5Y1Wwqv8s0])\n\n\nUSER INTERACTION\n\nThe user experience of using encrypted transactions is very similar compared to\nnormal ones, and involves only a few additional steps in the transaction\nsubmission and status notification process. When using a specific Dapp frontend,\nan action that posts a transaction to the blockchain will be handled in the\nfollowing way:\n\nThe user will be informed beforehand that the gas mechanism of this transaction\nis handled differently and the value transferred to the inbox contract is a\npre-payment of gas for execution of the revealed transaction. In the background,\nthe Dapp will locally handle the gas estimation of the payload, eventually fetch\nthe relevant encryption inputs from the L2 chain, and encrypt the payload.\n\nThe Dapp then constructs a normal Ethereum transaction that calls the commit\nfunction of the Shutter Inbox Contract and adds the calculated execution-gas to\nthe transaction’s value field.\n\nNext, the Dapp will ask the user’s wallet to send the transaction, which in turn\nwill prompt the user to sign it. Finally, the wallet will submit the signed\ntransaction to the Optimism JSON RPC endpoint.\n\nThe Dapp will then continuously show the current execution status of the user’s\ntransaction – but execution confirmation will take longer than usual: As a first\npre-confirmation, the Dapp will check the layer 2 chain for successful inclusion\nof the Shutter Inbox call in the latest block. As soon as the Commit Transaction\nhas been included, the user will see the status of the transaction as\n“committed, waiting for decryption and execution”.\n\nOnce the corresponding decrypted payload is found in the Reveal Transaction of\nthe next block and executed successfully, the user will see the status of the\ntransaction as “revealed, successfully decrypted and executed”. The Dapp may\nread the receipt of the Reveal Transaction and construct more detailed\ninformation on the transaction’s execution. Among others, this receipt indicates\nif execution was successful or if it reverted, e.g. due to running out of gas.\n\nIn case the Reveal Transaction receipt does not contain a trace of the decrypted\npayload, it was invalid.\n\n\nINTERACTION WITH DECENTRALIZED SEQUENCERS\n\nDecentralized Sequencer and MEVA designs are largely orthogonal to this\nproposal. The only requirements for Shutterized Optimism on the block proposal\nmechanism are that they come with a certain degree of finality, or achieve it\nquickly over time (without additional blocks).\n\n\nFINALITY ASSUMPTION\n\nThe system assumes that unsafe heads are final, as the keypers release the\ndecryption key immediately upon observing them. If they are not, i.e., if a\nmalicious sequencer can create a competing fork, this sequencer would be able to\nfrontrun. Note that this attack would be both provable and attributable. We\ntherefore recommend that the sequencer has to deposit a stake that will be\nslashed in case the sequencer attempts this attack.\n\n\nPOTENTIAL ISSUES AND SOLUTIONS\n\n\nLIVENESS FAILURES\n\nThe main failure to consider is a liveness failure caused by the keypers not\nproducing the decryption key. This would prevent the sequencer from proposing\nthe next valid block. For this scenario to take place, Shutter’s threshold\nassumption has to break: More than 1 - t keypers have to be offline, where t is\nthe threshold parameter.\n\nTo recover from this and similar types of failure, Shutter can be disabled by a\nsmart contract emergency switch. In that case, the rollup’s operation would fall\nback to standard Optimism mode. In particular, this would allow the sequencer to\nproduce a block without including the decryption key, so that the system can\ncontinue to make progress. This cannot be used to frontrun as encrypted\ntransactions will never be decrypted nor executed. Various options exist for\nwhich entities could trigger the emergency switch: The sequencer, OP governance,\nShutter governance, or a subset of the keyper set itself. In addition, the\nswitch could be conditional on the duration in which no block has been produced.\n\n\nLATENCY\n\nEncrypted transactions are executed over the course of two blocks (commit in\nsome block, reveal in the next). Naturally, their latency until execution\nincreases by a factor of two. Latency until inclusion of the Commit Transaction\nis still only a single block (note that inclusion guarantees later execution).\nStandard transactions are largely unaffected by Shutter, so they will still be\nincluded and executed in the next block.\n\nHowever, building a block now involves generating the decryption key. Since this\nis carried out in a distributed manner over a P2P network, the default block\ntime may have to be increased. The exact number will depend on the number of\nkeypers and network latency, but a cautiously optimistic estimate is 4s.\n\n\nSEQUENCER SIDE-CHANNEL ATTACK\n\nThe design involves a potential issue related to the sequencer’s ability to\nfreely choose block attributes. This control enables the sequencer to affect the\nexecution path of previously committed transactions at a time when they already\nknow the decryption key. This allows them to frontrun.\n\nFor instance, the sequencer may include a transaction at the top of the block\nthat buys a token on a DEX if the block timestamp is even and sells it if it is\nodd. As soon as they receive the decryption key, they can decrypt the other\ntransactions, and learn about the resulting price movement over the course of\nthe block. By choosing the timestamp for the next block accordingly (even if it\nincreases, odd if it decreases), they can effectively frontrun.\n\nThe sequencer can thus potentially gain an unfair advantage by executing\ntransactions based on privileged information before other participants.\n\nAs a possible prevention mechanism, the sequencer has to commit to all variable\nblock parameters already in the previous block. In order to prevent any degrees\nof freedom in the block attributes, the sequencer has to pre-commit to the block\nattributes difficulty, layer1-origin-hash, coinbase, and timestamp.\n\nHowever, this step has to be carefully considered in order to make sure normal\noperation is not negatively affected.\n\n\nDESIGN OPTIONS\n\n\nBLOCK OR TRANSACTION KEYS\n\nShutter uses an identity-based encryption scheme. This means that the encryption\nkey is derived from the eon public key and an identity, an arbitrary parameter.\nThis parameter is also used when the corresponding decryption key is generated.\nThere are two major options how to choose the identity:\n\n * one identity per block (e.g., the block number)\n * one identity per transaction (e.g., a custom nonce)\n\nThe advantage of block keys is efficiency: Only a single decryption key per\nblock has to be generated and included in each block. However, they have a\nnegative UX impact: Before sending a transaction, users have to figure out what\nthe identity value of the next block will be (or rather, the identity value of\nthe block in which they want their payload to be executed). This can be\ndifficult if network latency is high and may lead to higher confirmation times\nif users have to estimate more conservatively. In addition, encrypted payloads\nwill be revealed even if the transaction is not included at all, e.g., due to\nhigh latency, network congestion, or a malicious sequencer. Note however, that\nan already revealed transaction can not be included later on, so this does not\nmake the transaction susceptible for frontrunning.\n\nTransaction keys, on the other hand, can be derived purely locally without any\nknowledge over the state of the system. This makes the user experience maximally\nstraightforward and prevents revelation without inclusion. On the other hand,\nthe system is less efficient because for each transaction a separate key has to\nbe included.\n\n\nFUTURE CONSIDERATIONS\n\nFor the purpose of this proposal, practicality and low implementation complexity\nwere primary goals. When these become less important in future versions, more\noptions open up. Here we describe three.\n\nInstead of including encrypted transactions in the chain and decrypting them\nduring execution, it is possible to do the opposite: Only commit to a hash of\nall encrypted payloads, and at time of execution only include the decrypted\npayloads. As part of the state transition function, the payloads would be\nencrypted again in order to check correctness against the commitment. This\napproach is more efficient: Decrypted transactions can be compressed much better\nthan encrypted ones, so they use less of the expensive L1 space.\n\nThe main drawback of this, however, is a much higher complexity in the\nsequencer: They need to keep track of which transactions they have committed to\nin the previous block. If they lose this data, e.g., during a crash at an\ninconvenient time, they will be unable to produce a valid block and the system\nis stuck.\n\nZero knowledge proofs are another potential tool to increase efficiency: A\nzkSNARK that proves correct decryption would allow omitting the decryption keys\nfrom the chain altogether, thus severely limiting the L1 footprint of the\nsystem, in particular if transaction keys instead of block keys are chosen.\nFurthermore, users could use zero knowledge proofs to make statements about\ntheir account balances without revealing the sender account, which in the\ncurrent system is leaked to potential attackers. Unfortunately, zero knowledge\ntechnology is still somewhat complex.\n\nLastly, a potential modification to make reorg attacks by the sequencer much\nharder is to involve the keyper committee: In addition and simultaneous to the\ndecryption key generation, they could produce a threshold signature on the\ncurrent head of the chain. The state transition function would check this\nsignature in order to make sure that no reorg has happened. In order to\nsuccessfully attack, the sequencer would thus not only have to produce a\ncompeting block, but also require the keypers to sign it off.\n\n\nCONCLUSION\n\nIn this document, we have proposed modifications to the OP Stack to provide\nfront-running protection and censorship resistance to its users. The required\nchanges are relatively small in scale, not overly complex, and viable to\nimplement.\n\nWe have evaluated failure cases and outlined robust solutions for such\nscenarios, with the legacy system always serving as a fallback point to recover\nto, even in the worst-case.\n\nNotably, the proposed architecture does not compromise the user experience of\nnormal transactions, while also providing an only slightly diminished user\nexperience for front-running protected transactions. Importantly., it is\npossible to submit encrypted transactions with standard wallets, requiring only\nsmall frontend modifications that can be implemented straightforwardly by using\na provided library.\n\nOverall, the outlined software architecture lays a solid foundation for a\nfront-running protection system, balancing practicality, complexity, and\nsecurity.",
      "created_at": "2023-07-05T18:48:38.834Z",
      "trust_level": 1,
      "username": "Jannik",
      "admin": false,
      "moderator": false,
      "staff": false,
      "like_count": 5
    },
    {
      "content": "Due to character limits, we had to split this up into multiple posts. Here’s the\nwhole document\n[https://drive.google.com/file/d/1nsAnDZ6jv5AU413IvVp5tNgdtNewpHtJ] as a PDF.",
      "created_at": "2023-07-05T18:57:32.950Z",
      "trust_level": 1,
      "username": "Jannik",
      "admin": false,
      "moderator": false,
      "staff": false,
      "like_count": 5
    },
    {
      "content": "COMPONENTS\n\n\nKEYPER SET\n\nThe keyper set is a threshold-committee consisting of at least 20 members.\nDuring a setup phase, the keyper set generates the eon public key and broadcasts\nit. This key will be used by users to encrypt payloads. After each block\nproduced by the sequencer, the keyper set generates a decryption key that can be\nused to decrypt these payloads.\n\nIt is assumed that at least a certain number of keypers – the threshold – is\nonline and behaves honestly. If not, they can produce decryption keys before the\ncorresponding block has been produced and use this advance knowledge to frontrun\nin collusion with the sequencer.\n\n\nSEQUENCER\n\nThe job of Optimism’s sequencer is to receive transactions from users, build\nblocks, broadcast them, and submit them to L1. In addition to that, this\nproposal requires them to listen on a P2P network for decryption keys from the\nkeypers and produce blocks with slightly altered rules.\n\n\nSYSTEM CONTRACTS\n\nThe system relies on a small suite of smart contracts deployed on L2:\n\n * The Keyper Set Contract: Manages the set of keypers.\n * The Key Broadcast Contract: Acts as a billboard on which keypers can publish\n   the eon public key.\n * Shutter Inbox Contract: Collects encrypted payloads and metadata submitted by\n   users in the form of Commit Transactions.\n\n\nCLIENT LIBRARY\n\nThis frontend library provides functions for Dapps to easily\n\n * retrieve the eon public key from the Key Broadcast Contract,\n * create and encrypt payloads,\n * submit them to the Shutter Inbox Contract via Commit Transactions, and\n * be notified when they are included as well as decrypted and executed.\n\n\n\ncomponents\n[https://europe1.discourse-cdn.com/bc41dd/optimized/2X/2/2784f3aa198c4fa610c96cba3d4ebd11a03e394a_2_604x500.png]\ncomponents824×682 60.2 KB\n[https://europe1.discourse-cdn.com/bc41dd/original/2X/2/2784f3aa198c4fa610c96cba3d4ebd11a03e394a.png]\n\n\n\nDiagram of the different components making up the Shutterized Optimism System.\nArrows indicate the data flow starting with the user submitting a plaintext as\nwell as an encrypted transaction and ending with it being executed on the chain.\nNumbered text over arrows describe successive steps in the block building\nprocess. (high res\n[https://drive.google.com/file/d/1lcgcjGjZFoPR4wZr40dhQgZrAroCYrVq])",
      "created_at": "2023-07-05T18:47:47.410Z",
      "trust_level": 1,
      "username": "Jannik",
      "admin": false,
      "moderator": false,
      "staff": false,
      "like_count": 4
    },
    {
      "content": "PARTICIPANT REQUIREMENTS\n\nThis section defines requirements for a threshold encryption-based front-running\nprotection mechanism for OP Stack and Bedrock. They are high-level,\nsolution-agnostic, and primarily driven by the perspectives and needs of the\nparticipants in the system who are as follows:\n\n 1. End users: These are individuals who interact with the system, usually by\n    submitting transactions.\n 2. Optimism sequencer: The Optimism sequencer is a component of the Optimism\n    rollup architecture, responsible for ordering and executing transactions by\n    building new rollup blocks.\n 3. Optimism rollup node: The Optimism rollup node is a component of the\n    Optimism rollup architecture, syncing the rollup state from the sequencer\n    and the L1 chain.\n 4. Dapp project: Dapp projects provide some service to end users and typically\n    consist of a set of smart contracts deployed on the Optimism chain, a\n    browser-based frontend, and potentially additional components.\n\n\nEND USER\n\n 1. User experience and security should be comparable to using a Dapp on\n    Optimism today.\n 2. Users can submit encrypted transactions that cannot be frontrun.\n 3. Users can still send unencrypted transactions that have the same execution\n    guarantees as before.\n 4. Inclusion and execution latency for unencrypted transactions is similar to\n    the status quo.\n 5. Inclusion and execution latency for encrypted transactions is not much\n    higher than for unencrypted transactions.\n 6. Transaction fees for unencrypted transactions is the same as the status quo.\n 7. Transaction fees for encrypted transactions is not much higher than for\n    unencrypted transactions.\n\n\nDAPP PROJECT\n\n 1. Comprehensive documentation on the front-running protection mechanism is\n    available.\n 2. Existing front-end applications require no to minimal changes to remain\n    compatible.\n 3. A frontend library that handles the encryption, submission, and execution\n    status tracking of encrypted transactions is available.\n 4. Usage of the system requires no additional networking besides the existing\n    JSON RPC interface.\n\n\nOPTIMISM ROLLUP NODE\n\n 1. Setup and operation of the rollup node should be similar to the status quo.\n 2. Additional computational overhead of decrypting transactions does not\n    significantly impact hardware requirements.\n 3. Error handling and reporting mechanisms for issues related to transaction\n    decryption or processing are reliable and robust.\n 4. The node can scale in response to increased demand for encrypted\n    transactions.\n 5. Failures are handled gracefully.\n\n\nOPTIMISM SEQUENCER\n\nThe sequencer inherits the rollup node requirements.\n\n 1. The sequencer can plausibly argue that they no longer have the ability to\n    front-run transactions by design.\n 2. The sequencer can plausibly argue that they no longer have the ability to\n    censor transactions based on their content by design.\n 3. Encrypted and unencrypted transactions are processed within the same\n    pipeline.\n 4. The sequencer can reject encrypted transactions if they do not pay an\n    appropriate fee, taking into account the cost of both storing it on L1 as\n    well as executing it.\n\n\nCOMPONENT REQUIREMENTS\n\nThis section defines requirements for a concrete instantiation of a threshold\nencryption-based front-running protection mechanism, leveraging the Shutter\nNetwork. It first defines the main software components generally needed for such\na system and then states requirements on them.\n\nThe technical components in the system are as follows:\n\n 1. Optimism rollup node: The rollup node reads the L2 state from the\n    sequencer’s unsafe sync and occasionally compares it with the L2 state\n    locally derived from L1 sequencer batches and deposit data. The rollup node\n    also propagates unsafe, safe and finalized block data within a P2P network.\n    It uses the same software as the sequencer but in a different mode of\n    operation and as a different entity in the Optimism system.\n 2. Optimism sequencer node: The sequencer accepts transactions via a (private)\n    mempool and integrates them in new L2 sequencer batches, which will\n    eventually be included in an unsafe block,persisted on L1 and later included\n    in a finalized block.\n 3. Keyper set: The keypers run a distributed key generation (DKG) protocol.\n    This process outputs a single public key as well as one secret key share for\n    each participant. From the public key, encryption keys can be derived. The\n    keypers can compute the corresponding decryption key in a collaborative\n    manner. The process assumes that at least a certain fraction (e.g. 2/3) is\n    honest and online.\n 4. Frontend library: The frontend library helps Dapps to use encrypted\n    transactions in the user interface.\n\n\nFUNCTIONAL REQUIREMENTS\n\n\nOPTIMISM ROLLUP NODE\n\n 1. The rollup node reads decryption keys from the chain.\n 2. The rollup node verifies correctness of decryption keys.\n 3. The rollup node decrypts encrypted transactions included in the chain with\n    the decryption key.\n 4. The rollup node executes decrypted transactions in the order that the\n    sequencer has arranged the corresponding encrypted transactions in the\n    block.\n 5. The changes do not affect inclusion and execution of deposit transactions.\n 6. The state does not progress without decryption keys to prevent frontrunning.\n 7. The system provides a mechanism to indefinitely stop execution of encrypted\n    transactions in case the keypers fail to produce decryption keys.\n 8. The rollup node implementation is based on the OP Mainnet node with minimal\n    modifications.\n\n\nOPTIMISM SEQUENCER NODE\n\n 1. The sequencer accepts both plaintext and encrypted transactions through the\n    existing mempool.\n 2. The sequencer chooses to include encrypted transactions in a block if they\n    pay a fee appropriate to its resource requirements at both inclusion and\n    execution time.\n 3. The sequencer has a guarantee at inclusion time that encrypted transactions\n    pay a fee for their execution.\n 4. The sequencer receives decryption keys from the keypers and includes them in\n    their blocks after validating them.\n 5. The sequencer does not store state in memory that if lost would prevent the\n    chain from making progress.\n 6. The sequencer implementation is based on the OP Mainnet sequencer with\n    minimal modifications.\n\n\nKEYPER\n\n 1. The keypers generate a public key used to derive encryption keys and\n    broadcast it on L2.\n 2. The keypers read the keyper set membership and peer information from a\n    contract on L2.\n 3. The keypers generate the decryption keys for encrypted transactions.\n 4. Hardware requirements should allow running a keyper node on a consumer grade\n    laptop given access to an external rollup node.\n 5. In order to circumvent sequencer censorship, the keyper is able to send\n    deposit transactions via L1.\n 6. The keyper software is implemented in Go.\n\n\nFRONT END LIBRARY\n\n 1. Comprehensive documentation of the library API and usage patterns exists\n 2. The library exposes a small API surface and hides away implementation\n    details\n 3. The library integrates well with existing commonly used front-end libraries.\n 4. The library is implemented in JavaScript or TypeScript.\n\n\nNON-FUNCTIONAL REQUIREMENTS\n\nDisclaimer: At this stage in the architectural planning process, these are\nprovisional estimates for non-functional requirements and are subject to change.\n\n 1. At least 20 keypers\n 2. New epoch every 4 seconds.\n 3. Inclusion confirmation within one block.\n 4. Execution confirmation for unencrypted transactions within one block.\n 5. Execution confirmation for encrypted transactions within two blocks.\n 6. No gas overhead for unencrypted transactions.\n 7. Less than 3x gas cost for a typical encrypted transaction.\n\n\nTECHNICAL ARCHITECTURE OF SHUTTERIZED OPTIMISM\n\n\nOVERVIEW\n\nThe main addition to the stack is the set of keypers, a committee responsible\nfor generating keys that will be used to encrypt and decrypt transactions. Its\nmembers are managed by a contract on L2, the Keyper Set Contract. In a one-time\nsetup phase, they generate the so-called eon public key and broadcast it via the\nKey Broadcast Contract.\n\nIn addition to standard transactions, the system allows users to send encrypted\ntransactions that will be protected from frontrunning and censorship. To do so,\nusers have to first create the payload (consisting of receiver, calldata, and\nvalue) and then encrypt it with the eon key. They then submit the encrypted\npayload to the Shutter Inbox Contract via a so-called Commit Transaction. The\ncontract stores the payload in its storage and charges the user a fee which\ncovers the gas the scheduled transaction is going to use when being executed.\nThe amount is derived from the gas price as well as a user-provided gas limit\nand sent via the Commit Transaction’s value field.\n\nWhenever the sequencer seals a block, the keypers collaboratively generate the\ndecryption key for it and broadcast it on a P2P network. The sequencer picks it\nup and puts it – in the form of a so-called Reveal Transaction – at the front of\nthe block. Executing this transaction will result in all encrypted transactions\nthat have been scheduled previously being read from the ShutterInbox Contract,\nbeing decrypted and executed.\n\nThe state transition function ensures that the sequencer plays by the rules,\ni.e., that blocks fulfill the structure outlined above. In particular, blocks\nwithout a decryption key at the top (or an incorrect one) are invalid.\n\n\n\nblock-diagram\n[https://europe1.discourse-cdn.com/bc41dd/optimized/2X/b/bb1092a79bcbe1d82d7e8c8044da12b8bd634dc3_2_690x147.png]\nblock-diagram961×205 27.2 KB\n[https://europe1.discourse-cdn.com/bc41dd/original/2X/b/bb1092a79bcbe1d82d7e8c8044da12b8bd634dc3.png]\n\n\n\nInternal structure of blocks: Time increases from left to right, with decryption\nprocesses between the blocks. Inside of the block structure, transactions are\nexecuted in a left to right order. Decrypted payloads committed one block\nearlier are executed within the “Reveal Transaction” at the beginning of the\nblock. (high res\n[https://drive.google.com/file/d/1Ojy9dJ_2rWQl2G1QvajCthXTWX2MuEZc])",
      "created_at": "2023-07-05T18:47:17.714Z",
      "trust_level": 1,
      "username": "Jannik",
      "admin": false,
      "moderator": false,
      "staff": false,
      "like_count": 3
    }
  ],
  "created_at": "2023-07-05T18:45:51.185Z"
}