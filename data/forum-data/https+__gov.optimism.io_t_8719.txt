{
  "title": "Retro Funding 5 Guest Voter Selection Algorithm Explanation",
  "content": "In this experiment, we wanted to rank developers, identified by their GitHub\naccounts, based on their proximity to OP Stack repos. We trialed a unique\napproach with a custom implementation of the EigenTrust algorithm.\n\nSpecial thanks to Carl Cervone (Open Source Observer), Emily Furlong (Optimism\nFoundation) and Eugene Kim (OpenRank), Jenya Nepoimannykh (OpenRank).\n\n\nTHE FOUNDATIONAL METHOD: CAPTURING THE WEB OF TRUST VIA RECURSIVE TRUST GRAPH\n\nGiven a community of peers, their interactions with each other form a directed\ngraph. Here, the peers become nodes within the graph and their interactions are\nthe graph edges. These asymmetric edges can be viewed as trust arcs from one\npeer to the other. Additionally, the weight of each edge signals the degree of\ntrust imparted by one peer onto another.\n\nThe EigenTrust algorithm can then be run on such graphs to measure the impact of\nrecursive trust propagation, leading to a global trust value for each peer or\nnode in the network. Thus, every node gets assigned a reputation score. In a\nbipartite graph, there are two types of nodes, for example, GitHub repos as well\nas GitHub users as givers and receivers of trust forms a bipartite graph.\nEigenTrust not only works well with peer-to-peer data, but it can also be used\nfor bipartite graphs, the implementation of which is achieved using the Hubs and\nAuthorities algorithm. In a bipartite graph, there are two types of nodes, for\nexample, GitHub repos as well as GitHub users as givers and receivers of trust\nforms a bipartite graph.\n\n\nTHE GOAL OF THE EXERCISE AND THE CHOICE OF ALGORITHM\n\nGoal\n\nTo rank developers, identified by their GitHub accounts, based on their\nproximity to OP Stack repos.\n\nApproach\n\nOpenRank enables verifiable compute for a large class of reputation algorithms,\n**in particular those that (a) operate on a graph, (b) are iterative in nature\nand (c) have a tendency toward convergence. In the following sections, we give a\nbrief overview of some of these algorithms.\n\nFor our Developer ranking use case, we obtained a graph of relevant GitHub event\ndata from Open Source Observer, covering more than 2,000 organizations and over\n30,000 code repositories. We established two kinds of peers: GitHub users and\nrepositories. We then used a variation of EigenTrust, the Hubs and Authorities\nalgorithm, which computes rankings on an asymmetric bipartite trust graph.\n\nBelow are the two different trust edges used in the graph:\n\n * User-to-repository trust - this signals the user’s interest in the repository\n   through actions such as stars, forks and issue/PR submissions.\n * Repository-to-user trust - this signals the credit extended by the repository\n   to the user for their contribution. Actions such as PRs merged, direct code\n   commits received, and other maintenance actions.\n\nThe reason for using these two different and asymmetric trust arcs between users\nand GitHub repositories is to ensure accuracy and sybil resistance in the\nrankings. For trust-critical use cases, shared interest signal is often not\nnecessarily a good measure of trust. For example, sybil actors can create\nthousands of trust arcs directed to a malicious or irrelevant repository. We\nsolve this in two ways, choose a set of somewhat trustworthy/useful seed peers\n(GitHub repositories); and using a trust arc from a repository to a user based\non a relevant credit signal such as merging a PR.\n\nOnce the compute is run, the resulting global trust can be used for ranking both\nusers and GitHub repositories.\n\n\nCOMPUTE MODEL ASSUMPTIONS AND WEIGHTS\n\n\nTRUST SIGNALS\n\nIn this model, we use developers (GitHub username) and OP Stack repositories as\nnodes in the trust graph. We establish trust arcs between users and repositories\nand vice versa in the following manner:\n\nUser-to-repository actions (interest signals) include:\n\n * Starring the repository\n * Forking the repository\n * Opening an issue\n * Opening a pull request\n * Directly committing to the repository\n\nRepository-to-user actions (credit signals) include:\n\n * Having a pull request merged into the repository (approximated by opening of\n   a pull request as of this exercise)\n * Directly committing to the repository\n * Repository maintenance, such as merging a PR, resolving an issue, etc.\n\n\nCHOICE OF SEED PEERS AND ALPHA VALUE\n\nSeed peers are core OP Stack repo, weighted by their relative importance.\n\n * Core repos with higher importance (weight =2)\n   ‘testinprod-op-erigon’\n   ‘a16z/magi’,\n   ‘ethereum-optimism/optimism’,\n   ‘ethereum-optimism/op-geth’,\n   ‘ethereum-optimism/asterisc’,\n   ‘ethereum-optimism/kona’,\n   ‘ethereum-optimism/design-docs’,\n   ‘ethereum-optimism/specs’\n\n * Other core repos with importance (weight=1)\n   \n   ‘ethereum-optimism/superchain-ops’,\n   ‘ethereum-optimism/op-analytics’\n\nAlpha (α) Value\n\nα is a paratermer in EigenTrust algorithm that determines the significance of\nseed peers influence that shapes the reputation score of every other peers in\nthe entire network. Alpha value is normally chosen between 0 and 0.5 and the\nhigher the alpha the stronger the influence of seed peers, meaning the trust arc\nfrom seed peers to other peers will matter more for a peer’s relative\nreputation.\n\nA weak alpha value ( α=0.2 ) is chosen in this exercise, intending to discover\nmore repos related to OP stack, and attribute contribution back to developers.\nRelatively less influential seed peers could let the other peers express more\nreputation credit to other repos and peers, therefore suits the purpose of the\nexercise. To read more about alpha value, check out the EigenTrust documentation\nhere. [https://docs.openrank.com/reputation-algorithms/eigentrust]\n\n\nREASONING OF THE WEIGHTS CHOICES FOR TRUST ARCS\n\nThe weight ratio in the same class of actions (user-to-repo, or repo-to-user)\nmatters.\n\nUser-to-repo weights signals the seriousness of interest as well as the effort\nthat would go into the action. Least to most significant: Forking < (committing\ndirectly, starring) < (opening issue, merging PR) < opening PR. A relative\nweight was assigned accordingly.\n\n * Forking is a chore when someone wants to take a look at the repo and try\n   something out quickly. (weight=1)\n * Starring is a long-term interest signal to get updates from the repo and also\n   skew the feed. (weight=5)\n * Opening an issue actually takes nonnegligible effort. (weight=10)\n * Opening a PR takes more effort as it also has proposed changes. PR opening\n   reflects an original work. (weight =20)\n * PR merging reflects a maintenance/review action. Typically it takes more\n   effort for someone to create a patch and open a PR than to review it. (weight\n   =10)\n * Direct commits would normally sit between opening an issue and opening a PR;\n   there are a lot of automated direct commits/pushes so we dial it down to the\n   same level as opening an issue. (weight=5)\n\nRepo-to-user weight signals the degree of credit “thank you” from the repo(’s\nmaintainers) to contributors (users). It can be thought of credit/“thank you”\nfrom the repository to the contributors. Least to most significant: merging PR\n(maintainer action) < direct commits (maintainer/allow-listed contributor\naction) < authoring and submitting a PR (which was eventually merged). A\nrelative weight was assigned accordingly.\n\n\nITERATION ON THE RANKING RESULTS\n\nThere were several rounds of iteration on the algorithm, but it should by no\nmeans be interpreted to be in its final state. The process of adjusting and\nimproving an algorithm of this type is a continuing effort and we imagine that\nthis algorithm still has room for improvement, but is of sufficient quality for\nuse in this experiment.\n\nThe first iteration of the algorithm appeared to overvalue outdated repos, so we\nadded a time decay function. We also adjusted the weight of seed repos to\nreflect the relative importance to the OP stack. In running the algorithm we\ndiscovered that the choice between an alpha value of 0.5 and 0.2 did not have a\nsignificant effect on the ranking.\n\n\nDISCUSSION: FUTURE OPTIMIZATIONS AND SYBIL-RESISTANCE\n\nThis is the first iteration of using OpenRank to compute reputation within OP\nStack based on data inputs from Open Source Observer, eg: Github event data. A\nfew topics can be explored further.\n\n\nADDITIONAL SIGNALS FOR INCREASING MODEL PERFORMANCE AND SYBIL RESISTANCE\n\n * Using real (non-approximated) signal of having a pull request merged into the\n   repository\n   * Instead of approximating “opened PR = merged PR”\n * Parsing GitHub events for more concrete signs of collaboration (eg, comments\n   on issues, co-authored pull requests) and assessing the quality of those\n   collaboration signals (eg, a conversation taking place over multiple weeks\n   might be higher signal than one over a shorter interval)\n * Both interest signals and credit signals are captured in the same local trust\n   matrix. The local trust may also capture user-user and repo-repo trust\n   signals (the latter being, once again, the success attribution signals), so\n   the graph is not necessarily bipartite. Some examples:\n   * Following/Starring other users\n   * Repository dependencies (if repo A depends on repo B, A’s success should be\n     attributed to B)\n\n\nFACTORING ACTION’S SIZE INTO THE TRUST ARC WEIGHT\n\n * Example: PR importance (e.g. documentation fix < a whole new feature)\n   * Subjective factor (what kind of PR is it? feature? bug fix? doc? does the\n     project use labels for these?)\n   * Objective factor (change size?)\n\n\nEXPANDED SEED TRUST\n\n * Use a wider selection of OP-related repos so users’ contribution to those\n   repos will directly increase the user’s trust standing via the seed trust\n * Try and include both actors and objects in the seed. Actors-only or\n   objects-only seed trust often yields to slow convergence.\n * Associate different weights to seed repos, e.g. according to their importance\n\n\nABOUT OPENRANK\n\nOpenRank [https://openrank.com/] is a decentralized ranking and reputation\nprotocol. It enables a verifiable reputation compute layer for the open web that\nunlocks a broad range of useful applications, including those that resist\ncryptographic or game-theoretic mechanisms of trust. Using graph compute\nalgorithms like EigenTrust, it offers resilience from sybil contexts, provides\nscalable and context-specific compute, and enables permissionless access to\ncompute and reputation data for any developer.\n\n\nTHE VERIFIABILITY OF OPENRANK POWERED REPUTATION SCORES\n\nAs a reputation protocol, the permissionless verifiability of the scores is a\nkey property of OpenRank’s proposition. The verification methods that we propose\nare far cheaper than verification of general purpose computations, based on the\nintuition that iterative convergent algorithms on a graph are expensive to\ncompute, but inexpensive to check (typically requiring one matrix-vector\nmultiplication to check for convergence). This makes it far more practical to\nuse this reputation computer for these use cases than a general purpose\ndecentralized compute network.\n\nContact gloria@karma3labs.com [gloria@karma3labs.com] to access the full\npreliminary litepaper.\n\n\nGITHUB LINK OF THE OPEN SOURCED CODE\n\ngithub.com\n[https://github.com/openrankprotocol/interest-and-credit-notebooks/blob/main/OpenRank%20%2B%20GitHub%20I%26C%20for%20Retrofunding%20R5%20Voter%20Selection.ipynb]\n\nOPENRANKPROTOCOL/INTEREST-AND-CREDIT-NOTEBOOKS/BLOB/MAIN/OPENRANK + GITHUB\nI&AMP;C FOR RETROFUNDING R5 VOTER SELECTION.IPYNB\n[https://github.com/openrankprotocol/interest-and-credit-notebooks/blob/main/OpenRank%20%2B%20GitHub%20I%26C%20for%20Retrofunding%20R5%20Voter%20Selection.ipynb]\n\n{\n  \"nbformat\": 4,\n  \"nbformat_minor\": 0,\n  \"metadata\": {\n    \"colab\": {\n      \"provenance\": [],\n      \"include_colab_link\": true\n    },\n    \"kernelspec\": {\n      \"name\": \"python3\",\n      \"display_name\": \"Python 3\"\n    },\n    \"language_info\": {\n      \"name\": \"python\"\n    },\n    \"widgets\": {\n      \"application/vnd.jupyter.widget-state+json\": {\n        \"9a99368029a64ab38231bff75c464d70\": {\n          \"model_module\": \"@jupyter-widgets/controls\",\n          \"model_name\": \"HBoxModel\",\n\n\nThis file has been truncated. show original\n[https://github.com/openrankprotocol/interest-and-credit-notebooks/blob/main/OpenRank%20%2B%20GitHub%20I%26C%20for%20Retrofunding%20R5%20Voter%20Selection.ipynb]\n\n",
  "views": 28,
  "like_count": 1,
  "word_count": 1772,
  "answer": [],
  "created_at": "2024-08-14T09:30:00.898Z"
}